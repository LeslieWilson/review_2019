## Learning Objectives

- Learn about React controlled components
- Understand the one-way flow of data between parent and child controlled components
- Use React controlled components to create forms on our page

## Following Along - Code Example

To get quick set up, run the following and visit <http://localhost:8080>:

```no-highlight
$ et get react-forms
$ cd react-forms
$ yarn install
$ yarn run start
```

## Introduction

Traditional HTTP forms are static. The server renders a number of inputs on the page, and once the user fills out the form, they can choose to submit it (usually by clicking a "Submit" button.) At that point, a sort of snapshot is taken, capturing the current state of all of the inputs, and sending that data in an HTTP request back to the server. This behavior is a result of how HTTP works: once the server has sent the blank form, it forgets about it, and receives no further communication until the user makes their submission.

As you have probably come to expect, form components in React are much more dynamic. They make use of a parent component (often called a "container") to maintain information about not only the default, blank form, but also what changes as the user interacts with it and fills it out, in real-time. Each of the inputs of the form is rendered as a child component of that parent, which we called a _controlled component_.

## Containers

Here we have a simple food-tracking app, for documenting daily consumption. Take a look at this file:

```javascript
// src/containers/App.js

import React, { Component } from "react"
import FormContainer from "./FormContainer"
import MealsList from "../components/MealsList"

class App extends Component {
  constructor(props) {
    super(props)
    this.state = {
      meals: []
    }
    this.trackConsumption = this.trackConsumption.bind(this)
  }

  trackConsumption(submission) {
    let allMeals = this.state.meals
    this.setState({ meals: allMeals.concat(submission) })
  }

  render() {
    return (
      <div className="row">
        <div className="small-9 small-centered columns">
          <h1 className="text-center">Food Tracker</h1>
          <FormContainer trackConsumption={this.trackConsumption} />
          <MealsList meals={this.state.meals} />
        </div>
      </div>
    )
  }
}

export default App
```

Let's dissect this file.

- This is the highest-level component in our application. It creates two child components: `MealsList` and `FormContainer`. `MealsList` takes the list of meals as props, and `Formcontainer` takes the `trackConsumption` function as props.
- The `trackConsumption()` function adds a submitted meal to the array of meals in state.
- Pay particular attention to this line:

```javascript
this.trackConsumption = this.trackConsumption.bind(this)
```

`.bind`ing ensures that, even if there is another `trackConsumption` function somewhere in our program, the one that will be called will be in our `App` component. Any class function, called by `this.something`, will need to be bound in order for it to work. If you get an error saying your function is undefined, check and make sure you have a `.bind()` in your constructor.

- Notice, the `trackConsumption` function isn't called in this `App` container: it's passed down as a prop to the `FormContainer`, and called in the `handleFormSubmit()`.

```javascript
// src/containers/FormContainer.js

handleFormSubmit(event) {
  event.preventDefault();
    let formPayload = {
      food: this.state.foodItemConsumed,
      meal: this.state.mealSelected
    };
    this.props.trackConsumption(formPayload); //  formPayload gets passed to up to App.js
    this.handleClearForm(event);
  }
}
```

This pattern of passing a parent's function to be used in its child is also used in the `FormContainer` to create our controlled components.

## Controlled Components

There are two important characteristics of a controlled component, both having to do with the props which are passed down to it from its parent container. A controlled component receives:

1. A function that is called for every `onChange` event, which passes its input data up to the parent.
2. That same data, which is then displayed inside the input.

If that seems a little circular to you, that's because it is. It's an example of _unidirectional flow_: a simple cycle that ensures that both parent and child have access to the same data, generated by interaction with the user. Let's look at an example:

```javascript
// src/containers/FormContainer.js

render() {
  return (
    <form className="callout" onSubmit={this.handleFormSubmit}>
      <TextField
        content={this.state.foodItemConsumed}
        label='Food Item Consumed'
        name='consumed'
        handlerFunction={this.handleConsumedChange} // will become our onChange function
      />
      ...
    </form>
  );
}
```

```javascript
// src/components/TextField.js

const TextField = props => {
  return (
    <label>
      {props.label}
      <input
        name={props.name}
        type="text"
        value={props.content}
        onChange={props.handlerFunction}
      />
    </label>
  )
}
```

Notice that our `TextField` receives both of the props described above. It has a function, passed down as `handlerFunction`, which it calls `onChange`. And its input's `value` attribute is passed down to it as `content`. If this is truly a controlled component, that `handlerFunction` (which comes from the parent component, where it's called `handleConsumedChange`) must be setting the value of content. And it is:

```javascript
// src/containers/FormContainer.js

handleConsumedChange(event) {
  this.setState({ foodItemConsumed: event.target.value })
}
```

The `handleConsumedChange` function sets the value of the target (the input) into state as `foodItemConsumed`. This is how the value is eventually passed down to the `TextField` component as props, as `this.state.foodItemConsumed`. The same thing is being done with the props and value of the `Select` component. Examine it for yourself, and see if you can follow the flow of data.

![Unidirectional data flow diagram](https://s3.amazonaws.com/horizon-production/images/react-unidirectional-flow-detailed.png)

This powerful pattern is frequently leveraged when making forms in the React.js framework. Among other uses, it is considered a best practice way to pass your user-inputted data from container to presentational components, so that they may be displayed on the page.

## Summary

This article has defined controlled components, and explained their use to move data in a one-way loop, from child to parent and back again, which we call _unidirectional data flow_. This data flow is particularly useful when creating forms in our React apps, as it provides easy handles to respond to user input, without requiring a page load as would be needed in a traditional HTTP request/response cycle. Understanding this structure, and the way functions may be passed down to child components (and then invoked by them, to pass data up to their parents) is an important part of making fully-featured React front-end applications.

### External Resources

- [React Forms Official Documentation](https://facebook.github.io/react/docs/forms.html)
